.MODEL SMALL

;---------------BLOQUE DE DEFINICIONES---------------
    ;DIRECCIONES DE PERIFÉRICOS
        PA EQU 0400H
        PB EQU 0402H
        PC EQU 0404H
        PCC   EQU 0406H

        T0   EQU 0401H
        T1   EQU 0403H
        T2   EQU 0405H
        TCC  EQU 0407H

        INTADDR0   EQU 0408H
        INTADDR1   EQU 040AH

        DAC0808 EQU 0409H
        ADC0801 EQU 040BH
    ;--------------------------
    
    ;MÁQUINA DE ESTADOS PRICIPAL
        STINIT  EQU 0   ; ESTADO INICIAL
        STADC   EQU 1   ; ESTADO DE LECTURA DE ADC
        STDAC   EQU 2   ; ESTADO DE ESCRITURA EN DAC
        STREF   EQU 3   ; ESTADO DE DISPLAY
        STLSP   EQU 4   ; ACTUALIZAR ESTADO DE LEDS Y SPEAKER
    ;---------------------------

;----------FIN DE BLOQUE DE DEFINICIONES-------------

;-----------------BLOQUE DE MACROS-------------------
    WRITE_IO MACRO ADDR,DATA     ; MACRO PARA ESCRIBIR EN DIRECCIONES DE PERIFÉRICOS DE 8 BITS
        PUSH AX
            MOV DX,ADDR
            MOV AL,DATA
            OUT DX,AL
        POP AX
    ENDM

    READ_IO MACRO ADDRS,ADDRP   ; MACRO PARA LEER DIRECCIONES DE PERIFÉRICOS  DE 8 BITS
        MOV DX,ADDRP
        IN AL,DX
        MOV ADDRS,AL
    ENDM

    INCLUDEINTVECTOR MACRO ADDRINTV,ADDRINTP 
        PUSH DS
		MOV AX,0
		MOV DS,AX                   ;COLOCANDO EL SEGMENTO DE DATOS EN LA DIRECCIÓN 0.
        MOV SI,ADDRINTV             ;ESTABLECIENDO DIRECCIÓN DE CORRIMIENTO (PARA EL USUARIO DEBE SER POR MAYOR QUE 80H Y MÚLTIPLO DE 4)
		MOV [SI], OFFSET ADDRINTP   ;COPIANDO A DIRECCIÓN DE SEGMENTO EN LOS PRIMEROS DOS BYTES
		MOV [SI+2], SEG ADDRINTP    ;COPIANDO CORRIMIENTO EN LOS PROXIMOS DOS BYTES
		POP DS                      ;RECUPERANDO SEGMENTO DE DATOS 
    ENDM
;-------------FIN DE BLOQUE DE MACROS----------------

;-----------------BLOQUE DE DATOS--------------------
    .DATA 
        ORG 0200H
        STATE DB 0
        DACMEM DB 0
        ADCMEM DB 0

        DISCOUNT DW 0
        DISMEM DB 4 DUP(0)
;----------------------------------------------------

.STACK 100

.CODE
    ORG 0EF00H
    MAIN PROC FAR
        MOV AX,@DATA                ;CARGA AL REGISTRO AX LA DIRECCIÓN DESEADA PARA EL SEGMENTO DE DATOS.
        MOV DS,AX                   ;CARGA EL REGISTRO BASE DEL SEGMENTO DE DATOS CON LA DIRECCIÓN DESEADA.
        MOV ES,AX                   ;CARGA EL REGISTRO BASE DEL SEGMENTO EXTRA CON LA DIRECCIÓN DEL SEGMENTO DE DATOS.

        ;-----CONFIFGURACIÓN INICIAL-------
            CLI                 ; INTERRUPCIONES DESACTIVADAS.
            MOV DISCOUNT,1      ;   LIMPIANDO CONTADOR DE DISPLAY
    
            WRITE_IO PCC,10000000B   ; CONFIGURANDO PUERTOS A, B Y C COMO SALIDA.
    
            WRITE_IO TCC,00110110B   ; CONFIGURANDO TIMER 0 EN MODO 3 CON CONTEO BINARIO DE 16 BITS.
            WRITE_IO TCC,01010100B   ; CONFIGURANDO TIMER 1 EN MODO 2 CON CONTEO BINATIO DE 8  BITS.

            MOV AX,4200         ; CARGANDO TIMER 0 CON VALOR PARA PERIODO DE 5 MS.
            WRITE_IO T0,AL
            WRITE_IO T0,AH
            MOV AL,5            ; CARGANDO TIMER 1 CON VALOR PARA PERIODO DE 500 MS.
            WRITE_IO T1,AL

            INCLUDEINTVECTOR 080H,INTSTART      ; CONFIGURANDO VECTOR DE INTERRUPCIÓN PARA TECLA START.
            INCLUDEINTVECTOR 084H,INTSTOP       ; CONFIGURANDO VECTOR DE INTERRUPCIÓN PARA TECLA STOP.
            INCLUDEINTVECTOR 088H,INTT5MS       ; CONFIGURANDO VECTOR DE INTERRUPCIÓN PARA TEMPORIZADOR DE 5MS.
            INCLUDEINTVECTOR 08CH,INTADDRDC        ; CONFIGURANDO VECTOR DE INTERRUPCIÓN PARA ADC.

            WRITE_IO INTADDR0,00010011B     ; CONFIGURANDO ICW1.
            WRITE_IO INTADDR1,020H          ; CONFIGURANDO ICW2 (DIRECCIÓN BASE DE VECTOR DE INTERRUPCIONES EN REALIDAD ES 80H PERO EL MODELO DE PROTEUS TIENE UN ERROR).
            WRITE_IO INTADDR1,001H          ; CONFIGURANDO ICW4.
        ;----------------------------------

        CONFINITSTATE: 
            WRITE_IO PA,00H           ; APAGANDO ÁNODOS DE LAMPARAS
            WRITE_IO PB,0FH           ; APAGANDO CÁTODOS DE LÁMPARAS
            WRITE_IO PC,00H           ; APAGANDO LEDS Y BOCINAS Y TIMERS
            MOV STATE,STINIT        ; CARGANDO ESTADO INICIAL
            WRITE_IO INTADDR1,11111110B     ; ACTIVANDO INTERRUPCÓN DE TECLA START.
            STI                     ; ACTIVANDO INTERRUPCIONES EN EL 8086.
        
            INITSTATE:
                CMP STATE,STADC     ; ESPERANDO A CAMBIO DE ESTADO INIT POR STADC
            JNE INITSTATE
                WRITE_IO PC,0FH          ; ENCENDIENDO TIMERS 
                WRITE_IO INTADDR1,11110001B    ; DESACTIVANDO INTERRUPCIÓN DE TECLA START Y ACTIVANDO TECLA STOP,ADC Y REFREZCAMIENTO

            LOOPADC:
                WRITE_IO ADC0801,0

                ADCSTATE:
                    CMP STATE,STINIT        ; PREGUNTANDO SI EL ESTADO ACTUAL ES INIT
                    JE CONFINITSTATE        ; SI SE PULSA LA TECLA OFF TODO VOLVERÁ A LA CONFIGURACIÓN DEL ESTADO INICIAL
                        CMP STATE,STDAC     ; ESPERANDO A QUE LA INTERRUPCIÓN DEL ADC CAMBIE A ESTADO STDAC 
                JNE ADCSTATE

                CALL UPDATEMEM              ; ACTUALIZANDO MEMORIA DE ADC, DCA, DISPLAY Y EL ESATDO DE LOS INDICADORES
                WRITE_IO DAC0808,DACMEM          ; ACTIALIZANDO VALR DE SALIDA ANALÓGICA 
       
                REFSTATE:
                    CMP STATE,STINIT        ; PREGUNTANDO SI EL ESTADO ACTUAL ES INIT
                        JE CONFINITSTATE    ; SI SE PULSA LA TECLA OFF TODO VOLVERÁ A LA CONFIGURACIÓN DEL ESTADO INICIAL
                    CMP STATE,STREF         ; ESPERANDO A QUE LA INTERRUPCIÓN DE LOS 5MS CAMBIE A ESTADO DE REFRESCAMIENTO DE DISPLAY
                JNE REFSTATE

                CALL REFDISPLAY         ; REFRESCANDO DISPLAY
                MOV STATE,STADC         ; CARGANDO ESTADO ADC
            JMP LOOPADC                 ; SALTANDO A INICIO DEL BUCLE DE LECTURA DEL ADC
        RET
        
    MAIN ENDP

;-----------------PROCEDIMIENTOS-------------------
    UPDATEMEM PROC NEAR
        READ_IO ADCMEM,ADC0801      ; LEYENDO ADC Y CARGANDO VALOR EN "ADCMEM" 
        CMP ADCMEM,140          ; COMPARANDO CON LA VELOCIDAD MÁXIMA (140 EL EQUIVALENTE A 1400).
        JE RPMOK                ; SI ES IGUAL 140 IR A ACTUALIZAR LA MEMORIA DE DISPLAY (ESTÁ EN EL RANGO PERMITIDO).
            JA ISABOVE              ; SI ES MAYOR HAY QUE BAJAR LA VELOCIDAD.
              CMP ADCMEM,80         ; COMPARANDO CON EL VALOR MÍNIMO DE VELOCIDAD.
            JAE RPMOK               ; SI ES MAYOR O IGUAL 80 IR A ACTUALIZAR LA MEMORIA DE DISPLAY (ESTÁ EN EL RANGO PERMITIDO), DE LO CONTRARIO HAY QUE AUMENTAR LA VELOCIDAD. 
                READ_IO AL,PC        ; LEYENDO PURTO B PARA APLICAR MÁSCARAS.
                AND AL,11011111B    ; APAGANDO LED ROJO
                OR AL,11010000B     ; ENCENDIEDO LED VERDE, EL LED AMARILLO Y LA BOCINA.
                WRITE_IO PC,AL        ; CARGANDO DATOS EN PUERTO B.
                CMP DACMEM,0FFH     ; SI EL DAC ESTÁ AL MÁXIMO NO SE PUEDE INCREMENTAR MÁS
                JE UPDATEMEMDISP    ; SI NO ES EL MÁXIMO,PY INCREMENTAR
                    INC DACMEM      ; INCREMENTAR DAC
                JMP UPDATEMEMDISP   ; IR A ACTUAIZAR MEMORIA DE DISPLAY
            ISABOVE:
                READ_IO AL,PC        ; LEYENDO PURTO B PARA APLICAR MÁSCARAS.
                AND AL,01111111B    ; APAGANDO LED AMARILLO
                OR AL,01110000B     ; ENCENDIEDO LED VERDE, EL LED ROJO Y LA BOCINA.
                WRITE_IO PC,AL        ; CARGANDO DATOS EN PUERTO B.
                CMP DACMEM,0        ; SI EL DAC ESTÁ AL MÍNIMO NO SE PUEDE DECREMENTAR MÁS.
                JE UPDATEMEMDISP    ; SI NO ES EL MÁXIMO DECREMENTAR
                    DEC DACMEM      ; DECREMENTAR DAC.
                JMP UPDATEMEMDISP   ; IR A ACTUALIZAR MEMORIA DE DISPLAY
        RPMOK:
            READ_IO AL,PC        ; LEYENDO PURTO B PARA APLICAR MÁSCARAS.
            AND AL,01001111B    ; APAGANDO LED AMARILLO, LED ROJO Y LA BOCINA
            OR AL,01000000B     ; ENCENDIEDO LED VERDE.
            WRITE_IO PC,AL        ; CARGANDO DATOS EN PUERTO B.

        UPDATEMEMDISP:
            MOV DISMEM[3],0         ; LA ÚLTIMA LÁMPARA SIEMPRE ESTARÁ EN 0 POR LA FALTA DE RESOLUCIÓN DEL SENSOR DE VELOCIDAD
            MOV AL,ADCMEM           ; CARGANDO AL CON VALOR DE VELOCIDAD MEDIDA 
            MOV BL,10               ; ASIGNANDO 10 A "BL" PARA DIVIDIR "AL" Y OPTENER U,D Y C. 
            XOR AH,AH
            DIV BL                  ; PRIEMRA DIVISIÓN PARA OPTENER CENTENAS
            MOV DISMEM[2],AH        ; CARGANDO CENTENAS EN MEMORIA DE DISPLAY
            XOR AH,AH
            DIV BL                  ; SEGUNDA DIVISIÓN PARA OPTENER DECENAS
            MOV DISMEM[1],AH        ; CARGANDO DECENAS EN MEMORIA DE DISPLAY
            XOR AH,AH
            DIV BL                  ; TERCERA DIVISIÓN PARA OPTENER UNIDADES
            MOV DISMEM[0],AH        ; CARGANDO UNIDADES EN MEMORIA DE DISPLAY
        RET
    UPDATEMEM ENDP

    REFDISPLAY PROC NEAR
        PUSH BX
        PUSH AX

        WRITE_IO PB,0FH       ; APAGANDO CÁTODOS DE LEDS DE LÁMPARAS

        CMP DISCOUNT,4      ; PREGUNTANDO SI ESTÁ EN LA ÚLTIMA LÁMPARA
        JNE NOENDLAP
            MOV DISCOUNT,0  ;   REINICIANDO CONTADOR DE DISPLAY
        NOENDLAP: 

        MOV BX,DISCOUNT             ; CARGANDO DESPLAZAMIENTO DE 
        MOV AH,0                    ; LIMPIANDO "AH"
        MOV AL,DISMEM[BX]           ; CARGANDO CARACTER DE LÁMPARA CORRESPONDIENTE
        MOV BX,OFFSET CHAR7SEGCC    ; CARGANDO OFFSET DE TABLA DE CARACTERES
        XLAT CS:CHAR7SEGCC          ; OBTENIEDO CARACTER
        WRITE_IO PA,AL                ; ESCRIBIENDO CARACTER EN PUERTO
        	

        MOV BX,OFFSET LAMPENABLE    ; CARGANDO BASE DE LÁMPARAS ACTIVAS
        MOV AX,DISCOUNT             ; CARGANDO DESPLAZAMIENTO
        XLAT CS:LAMPENABLE

        WRITE_IO PB,AL        ; ENCENDIENDO LÁMPARA CORRESONDIENTE
        INC DISCOUNT        ; INCREMENTAR CONTADOR DE DISPLAY
        
        POP AX
        POP BX
        RET

        ;TABLAS PARA LÁMPARAS 7-SEGMENTOS CÁTODO COMÚN
        LAMPENABLE  DB  11111110B
                    DB  11111101B
                    DB  11111011B
                    DB  11110111B

        CHAR7SEGCC  DB	00111111B ;0
                    DB  00000110B ;1
                    DB  01011011B ;2
                    DB  01001111B ;3
                    DB  01100110B ;4
                    DB  01101101B ;5
                    DB  01111101B ;6
                    DB  00000111B ;7
                    DB  01111111B ;8
                    DB  01101111B ;9
    REFDISPLAY ENDP
;--------------------------------------------------
    
;-----------------INTERRUPCIONES-------------------
    INTSTART PROC NEAR
        MOV STATE,STADC         ; CARGANDO ESTADO DE LECTURA DE ADC
        WRITE_IO INTADDR0,01100000B     ; OCW2 (FIN DE INTERRUPCIÓN DE TECLA START)
        IRET
    INTSTART ENDP
    
    INTSTOP PROC NEAR
        MOV STATE,STINIT        ; CARGANDO ESTADO DE INICIO
        WRITE_IO INTADDR1,11111110B     ; ACTIVANDO INTERRUPCIÓN DE TECLA START Y DESCATIVANDO EL RESTO
        WRITE_IO INTADDR0,01100001B     ; OCW2 (FIN DE INTERRUPCIÓN DE TECLA STOP)
        IRET
    INTSTOP ENDP

    INTT5MS PROC NEAR 
        MOV STATE,STREF         ; CARGANDO ESTADO DE REFREZCAMIENTO DE DISPLAY
        WRITE_IO INTADDR0,01100010B     ; OCW2 (FIN DE INTERRUPCIÓN DE TEMPORIZADOR DE 5 MS)
        IRET
    INTT5MS ENDP

    INTADDRDC PROC NEAR
        MOV STATE,STDAC
        WRITE_IO INTADDR0,01100011B     ;OCW2 (FIND E INTERRUPCIÓN DE ADC)
        IRET
    INTADDRDC ENDP
;--------------------------------------------------

END MAIN